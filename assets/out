#!/bin/sh
# vim: set ft=sh

set -e

exec 3>&1 # make stdout available as fd 3 for the result
exec 1>&2 # redirect all output to stderr for logging

source $(dirname $0)/common.sh

source=$1

if [ -z "$source" ]; then
  echo "usage: $0 <path/to/source>"
  exit 1
fi

# for jq
PATH=/usr/local/bin:$PATH

payload=$(mktemp /tmp/resource-in.XXXXXX)

cat > $payload <&0

cd $source

insecure_registries=$(jq -r '.source.insecure_registries // [] | join(" ")' < $payload)

registry_mirror=$(jq -r '.source.registry_mirror // ""' < $payload)

start_docker "$insecure_registries" "$registry_mirror"

username=$(jq -r '.source.username // ""' < $payload)
password=$(jq -r '.source.password // ""' < $payload)
email=$(jq -r '.source.email // ""' < $payload)
repository=$(jq -r '.source.repository // ""' < $payload)

build_cache_host=$(jq -r '.source.build_cache.host // ""' < $payload)
build_cache_port=$(jq -r '.source.build_cache.port // ""' < $payload)
build_cache_user=$(jq -r '.source.build_cache.user // ""' < $payload)
build_cache_private_key=$(jq -r '.source.build_cache.private_key // ""' < $payload)
build_cache_remote_path=$(jq -r '.source.build_cache.remote_path // ""' < $payload)

load_pubkey $payload

if private_registry "${repository}" ; then
  registry="$(extract_registry "${repository}")"
else
  registry=
fi

if [ -n "${username}" ] && [ -n "${password}" ] && [ -n "${email}" ]; then
  docker login -u "${username}" -p "${password}" -e "${email}" ${registry}
fi

tag_source=$(jq -r '.source.tag // "latest"' < $payload)
tag_params=$(jq -r '.params.tag // ""' < $payload)
tag_prefix=$(jq -r '.params.tag_prefix // ""' < $payload)
need_tag_as_latest=$(jq -r '.params.tag_as_latest // "false"' < $payload)


tag_name=""
if [ -n "$tag_params" ]; then
  if [ ! -f "$tag_params" ]; then
    echo "tag file '$tag_params' does not exist"
    exit 1
  fi
  tag_name="${tag_prefix}$(cat $tag_params)"
else
  tag_name="$tag_source"
fi

if [ -z "$repository" ]; then
  echo "must specify repository"
  exit 1
fi

build=$(jq -r '.params.build // ""' < $payload)
cache=$(jq -r '.params.cache' < $payload)

dockerfile=$(jq -r '.params.dockerfile // ""' < $payload)

load_base=$(jq -r '[.params.load_base] | flatten | .[] // ""' < $payload)

load_file=$(jq -r '.params.load_file // ""' < $payload)
load_repository=$(jq -r '.params.load_repository // ""' < $payload)
load_tag=$(jq -r '.params.load_tag // "latest"' < $payload)

import_file=$(jq -r '.params.import_file // ""' < $payload)

pull_repository=$(jq -r '.params.pull_repository // ""' < $payload)
pull_tag=$(jq -r '.params.pull_tag // "latest"' < $payload)

rootfs="$(jq -r '.params.rootfs' < $payload)"

if [ -n "$load_base" ]; then
  for base_name in $load_base
  do
    # Load all of the base images specified
    docker load -i "${base_name}/image"
    docker tag \
      "$(cat "${base_name}/image-id")" \
      "$(cat "${base_name}/repository"):$(cat "${base_name}/tag")"
  done  
fi

if [ -n "$build" ]; then
  if [ "$cache" = "true" ]; then
    docker_pull "${repository}:${tag_name}"
  fi

  if [ -n "$dockerfile" ]; then
    docker build -t "${repository}:${tag_name}" -f "$dockerfile" "$build"
  else
    docker build -t "${repository}:${tag_name}" "$build"
  fi
  
elif [ -n "$load_file" ]; then
  docker load -i "$load_file"
  docker tag "${load_repository}:${load_tag}" "${repository}:${tag_name}"
elif [ -n "$import_file" ]; then
  cat "$import_file" | docker import - "${repository}:${tag_name}"
elif [ -n "$pull_repository" ]; then
  docker pull "${pull_repository}:${pull_tag}"
  docker tag "${pull_repository}:${pull_tag}" "${repository}:${tag_name}"
else
  echo "must specify build or image param"
  exit 1
fi

image_id="$(image_from_tag "$repository" "$tag_name")"

if [ "$rootfs" = "true" ]; then
  docker run --cidfile=container.cid "$image_id" echo container created
  docker export $(cat container.cid) > ${destination}/rootfs.tar
fi

# afaict there's no clean way to get the digest after a push. docker prints
# this line at the end at least:
#
#   (tagname): digest: (digest) size: (size)
#
# so just parse it out

# careful to not let 'tee' mask exit status

{
  if ! docker push "${repository}:${tag_name}"; then
    touch /tmp/push-failed
  fi
} | tee push-output

if [ -e /tmp/push-failed ]; then
  exit 1
fi

digest="$(tail -1 push-output | awk '{print $3}')"

if [ "$need_tag_as_latest" = "true" ] && [ "${tag_name}" != "latest"  ]    ; then
  docker tag "${repository}:${tag_name}" "${repository}:latest"
  docker push "${repository}:latest"
  echo "${repository}:${tag_name} tagged as latest"
fi

if [ -n "${build_cache_host}" ] && [ -n "${build_cache_port}" ] && [ -n "${build_cache_user}" ] && [ -n "${build_cache_remote_path}" ]; then
  echo "Beginning docker save to preserve docker build cache."
  start=`date +%s`
  docker save $image_id $(docker history -q $image_id | tail -n +2 | grep -v \<missing\> | tr '\n' ' ') > image-with-history.tar
  end=`date +%s`
  runtime=$((end-start))
  echo "Finished docker save in ${runtime} seconds"
  echo "Beginning scp of image with build cache to build cache server.."
  start=`date +%s`
  ssh ${build_cache_user}@${build_cache_host} -p ${build_cache_port} "mkdir -p ${build_cache_remote_path}/${digest}"
  scp -P ${build_cache_port} image-with-history.tar ${build_cache_user}@${build_cache_host}:${build_cache_remote_path}/${digest}  
  end=`date +%s`
  runtime=$((end-start))
  echo "Finished scp of image to the build cache server in ${runtime} seconds"  
fi


jq -n "{
  version: {
    digest: $(echo $digest | jq -R .)
  },
  metadata: [
    { name: \"image\", value: $(echo $image_id | head -c 12 | jq -R .) }
  ]
}" >&3
